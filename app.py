import random
import os
import requests
import uuid # Used for stable unique ID generation
from flask import Flask, render_template, request, redirect, url_for, session
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import Integer, String, Boolean, ForeignKey, event
from typing import List, Optional

# --- Configuration and Data ---
app = Flask(__name__)

# IMPORTANT: NEVER use this default key in production. Use a Render Environment Variable instead.
app.secret_key = 'a_very_secret_key_for_hangman_game_123'

MAX_LIVES = 6

# --- NEW API CONFIGURATION ---
RAPIDAPI_KEY = os.environ.get('X_RAPIDAPI_KEY')
RAPIDAPI_HOST = os.environ.get('X_RAPIDAPI_HOST', 'wordsapiv1.p.rapidapi.com')
EXTERNAL_WORD_API_URL = "https://wordsapiv1.p.rapidapi.com/words/"

GENRE_LIST = [
    "Animals",
    "Sports",
    "Technology"
]


# Simplified ASCII art for the Hangman stages (0 to 6 misses)
HANGMAN_STAGES = [
"""
+---+
|   |
    |
    |
    |
    |
=====""",
"""
+---+
|   |
O   |
    |
    |
    |
=====""",
"""
+---+
|   |
O   |
|   |
    |
    |
=====""",
"""
+---+
|   |
O   |
/|  |
    |
    |
=====""",
"""
+---+
|   |
O   |
/|\ |
    |
    |
=====""",
"""
+---+
|   |
O   |
/|\ |
/   |
    |
=====""",
"""
+---+
|   |
O   |
/|\ |
/ \ |
    |
====="""
]

# --- Database Setup (PostgreSQL/SQLAlchemy) ---
# Use the PostgreSQL connection string from the Render environment
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')
db = SQLAlchemy(app)

# --- Database Models ---

# User model: Stores unique user identifier (session ID) and primary key
class User(db.Model):
    __tablename__ = 'user'
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    # This column now stores a stable UUID generated by the app, replacing session.sid
    username: Mapped[str] = mapped_column(String(80), unique=True, nullable=False)
    # User can optionally have an email, but not required for this app
    email: Mapped[Optional[str]] = mapped_column(String(120), unique=True, nullable=True)

    def __repr__(self):
        return f'<User {self.username}>'

# GameStats model: Stores overall wins and losses per user
class GameStats(db.Model):
    __tablename__ = 'game_stats'
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'), unique=True, nullable=False)
    wins: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    losses: Mapped[int] = mapped_column(Integer, default=0, nullable=False)

    def __repr__(self):
        return f'<Stats User:{self.user_id} Wins:{self.wins} Losses:{self.losses}>'

# Listener to automatically create GameStats entry when a new User is created
@event.listens_for(User, 'after_insert')
def create_default_stats(mapper, connection, target):
    """Note: This function is currently empty, but kept as a placeholder if needed later."""
    pass

# Context processor to ensure the DB and tables are ready
@app.before_request
def setup_db():
    # Only try to create tables if we are running in the main thread/process
    # In Gunicorn/Render, this helps ensure it runs once early on.
    if app.config['SQLALCHEMY_DATABASE_URI'] and not hasattr(app, '_db_setup_done'):
        with app.app_context():
            # Create tables only if they don't exist
            db.create_all()
            app._db_setup_done = True

# --- Database Utility Functions ---

def get_or_create_user():
    """
    Retrieves the user associated with the current session, or creates a new one.
    Uses a unique UUID stored in the session as the stable user identifier (username).
    """
    # Use a stable UUID to identify the user session, as session.sid is not reliable.
    user_identifier = session.get('user_identifier')

    if user_identifier is None:
        # If no identifier exists, generate a new one and store it in the session
        user_identifier = str(uuid.uuid4())
        session['user_identifier'] = user_identifier
        app.logger.info(f"Generated new session identifier: {user_identifier}")

    user_id = session.get('user_id')
    user = None

    with app.app_context():
        # 1. Try to find user by saved user_id in the session
        if user_id:
            user = db.session.get(User, user_id)
        
        # 2. If not found by ID, try to find user by the stable user_identifier (username)
        if user is None:
            user = db.session.execute(db.select(User).filter_by(username=user_identifier)).scalar_one_or_none()

        # 3. If still not found, create new user
        if user is None:
            try:
                # Use the stable UUID as the username
                user = User(username=user_identifier)
                db.session.add(user)
                db.session.commit()
                session['user_id'] = user.id # Save the new user's DB ID
                app.logger.info(f"Created new user with ID: {user.id} and username: {user_identifier}")
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Failed to create new user: {e}")
                return None

        # Always ensure the session has the correct ID
        session['user_id'] = user.id
        return user

def get_user_stats(user_id):
    """Retrieves wins and losses for a given user ID."""
    with app.app_context():
        stats = db.session.execute(db.select(GameStats).filter_by(user_id=user_id)).scalar_one_or_none()
        if stats:
            return stats.wins, stats.losses
        return 0, 0

def update_user_stats(user_id, is_win):
    """Updates the win/loss record for a user."""
    with app.app_context():
        stats = db.session.execute(db.select(GameStats).filter_by(user_id=user_id)).scalar_one_or_none()

        if not stats:
            # Create the GameStats row if it doesn't exist
            stats = GameStats(user_id=user_id, wins=0, losses=0)
            db.session.add(stats)

        if is_win:
            stats.wins += 1
            app.logger.info(f"User {user_id} recorded a WIN. Total wins: {stats.wins}")
        else:
            stats.losses += 1
            app.logger.info(f"User {user_id} recorded a LOSS. Total losses: {stats.losses}")

        try:
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Failed to update user stats: {e}")


# --- Game Utility Functions ---

def get_word_from_api(genre: str) -> Optional[str]:
    """Fetches a random word from the WordsAPI based on a genre definition."""
    if not RAPIDAPI_KEY:
        app.logger.warning("API Key missing. Falling back to default word list.")
        return None

    # WordsAPI uses 'topic' for genre filtering
    querystring = {"hasDetails": "definitions", "limit": "1", "random": "true", "topic": genre}
    headers = {
        "X-RapidAPI-Key": RAPIDAPI_KEY,
        "X-RapidAPI-Host": RAPIDAPI_HOST
    }

    try:
        response = requests.get(EXTERNAL_WORD_API_URL, headers=headers, params=querystring, timeout=5)
        response.raise_for_status() # Raises an HTTPError for bad responses (4xx or 5xx)

        data = response.json()
        word = data.get('word')
        
        # Basic validation: ensure the word exists and is all letters
        if word and word.isalpha():
            app.logger.info(f"Successfully fetched word: '{word}' for genre: {genre}")
            return word.upper()
        
        app.logger.warning(f"API returned invalid or empty word for genre {genre}: {data}")
        return None

    except requests.exceptions.Timeout:
        app.logger.error(f"API Request timed out for genre: {genre}")
    except requests.exceptions.HTTPError as e:
        app.logger.error(f"API Request failed with HTTP Error: {e.response.status_code} for genre: {genre}")
    except Exception as e:
        app.logger.error(f"An unexpected error occurred during API call: {e}")

    return None

def initialize_game_session(genre: str):
    """Initializes or resets all session variables for a new game."""
    # 1. Try to get a word from the API
    word = get_word_from_api(genre)
    
    # 2. If API fails, use a reliable fallback list
    if not word:
        # Fallback word list mapped to genres
        FALLBACK_WORDS = {
            "Animals": ["ELEPHANT", "TIGER", "DOLPHIN", "ZEBRA", "PENGUIN"],
            "Sports": ["SOCCER", "BASKETBALL", "TENNIS", "HOCKEY", "VOLLEYBALL"],
            "Technology": ["COMPUTER", "ALGORITHM", "KEYBOARD", "SOFTWARE", "INTERNET"]
        }
        word_list = FALLBACK_WORDS.get(genre, ["PYTHON", "FLASK", "DEBUG"])
        word = random.choice(word_list)
        app.logger.info(f"Using fallback word: '{word}' for genre: {genre}")

    session['word_to_guess'] = word
    session['guessed_letters'] = [] # Reset guessed letters
    session['lives'] = MAX_LIVES    # Reset lives
    session['is_game_over'] = False
    session['message'] = f"New game started in the **{genre}** category!"
    session['current_genre'] = genre

def get_display_word(word: str, guessed_set: set) -> str:
    """Returns the word with unguessed letters replaced by underscores."""
    display = ""
    for letter in word:
        if letter in guessed_set:
            display += letter + " "
        else:
            display += "_ "
    return display.strip()

# --- Flask Routes ---

@app.route('/', methods=['GET', 'POST'])
def hangman_game():
    # Ensure the user is identified before anything else
    user = get_or_create_user()
    if not user:
        # This occurs if the DB transaction failed.
        return "Internal Server Error: Could not establish user session for stats tracking.", 500

    # 1. Setup/Initialize State
    # Retrieve user stats for display (default to 0 if not found)
    user_wins, user_losses = get_user_stats(user.id)
    
    # Setup all variables from session, providing safe defaults
    word_to_guess = session.get('word_to_guess')
    # Use default empty list [] for guessed_letters to prevent TypeError on first run
    guessed_letters = session.get('guessed_letters', [])
    lives = session.get('lives', MAX_LIVES)
    current_genre = session.get('current_genre', GENRE_LIST[0])
    is_game_over = session.get('is_game_over', False)
    message = session.get('message', "")
    
    # Convert to set for efficient checking
    guessed_set = set(guessed_letters)

    # --- POST Handling (Game Logic) ---
    if request.method == 'POST':
        # Check if the user is changing the genre (Start New Game button)
        if 'genre_select' in request.form:
            new_genre = request.form['genre_select']
            initialize_game_session(new_genre)
            # Fetch the newly initialized state
            word_to_guess = session.get('word_to_guess')
            guessed_set = set(session.get('guessed_letters', []))
            lives = session.get('lives')
            current_genre = session.get('current_genre')
            is_game_over = session.get('is_game_over')
            message = session.get('message')
        
        # Check if the user is guessing a letter
        elif 'letter' in request.form and not is_game_over:
            guess = request.form['letter'].upper()
            
            # Input validation
            if not guess.isalpha() or len(guess) != 1:
                message = "Please enter a single valid letter (A-Z)."
            elif guess in guessed_set:
                message = f"You already guessed **{guess}**. Try a different letter."
            else:
                # Process the guess
                guessed_set.add(guess)
                if guess in word_to_guess:
                    message = f"‚úÖ Correct! **{guess}** is in the word."
                else:
                    lives -= 1
                    session['lives'] = lives
                    message = f"‚ùå Incorrect! **{guess}** is not in the word."
            
            session['guessed_letters'] = list(guessed_set)
            session['message'] = message
    
    # --- GET Handling (Initial Setup) ---
    else:
        # If this is a GET request and the word is not set, initialize the game
        if not word_to_guess:
            initialize_game_session(current_genre)
            word_to_guess = session.get('word_to_guess')
            guessed_set = set(session.get('guessed_letters', []))
            lives = session.get('lives')
            is_game_over = session.get('is_game_over')

    # 2. Update display word and check for Win/Loss state
    display_word = get_display_word(word_to_guess, guessed_set)
    is_win = "_" not in display_word
    is_loss = lives <= 0
    
    
    if not is_game_over:
        if is_win:
            is_game_over = True
            session['is_game_over'] = True
            session['message'] = f"üéâ YOU WON! The word was **{word_to_guess}**."
            update_user_stats(user.id, is_win=True)
            message = session['message']
            
        elif is_loss:
            is_game_over = True
            session['is_game_over'] = True
            session['message'] = f"üíÄ GAME OVER. The word was **{word_to_guess}**."
            update_user_stats(user.id, is_win=False)
            message = session['message']


    # 3. Render the template with the current state
    lives_index = MAX_LIVES - lives
    
    return render_template(
        'index.html',
        display_word=display_word,
        lives=lives,
        message=message,
        guessed_letters=sorted(list(guessed_set)), 
        is_game_over=is_game_over,
        hangman_art=HANGMAN_STAGES[lives_index],
        max_lives=MAX_LIVES,
        genres=GENRE_LIST,
        current_genre=current_genre,
        user_wins=user_wins,      # Pass stats for rendering
        user_losses=user_losses   # Pass stats for rendering
    )


@app.route('/restart')
def restart():
    """Restarts the game with the same word and genre."""
    # Retain the current genre and word, but reset game state
    genre = session.get('current_genre', GENRE_LIST[0])
    word = session.get('word_to_guess')

    if word and genre:
        # Reset game variables, keeping the word
        session['guessed_letters'] = []
        session['lives'] = MAX_LIVES
        session['is_game_over'] = False
        session['message'] = f"Game restarted! Guessing the same word in **{genre}**."
        app.logger.info(f"Game restarted with word: {word}")
    else:
        # If somehow we lost the word, just start a fresh game
        initialize_game_session(genre)
        app.logger.warning("Session word lost during restart, starting fresh game.")

    return redirect(url_for('hangman_game'))


@app.route('/new_word')
def new_word():
    """Starts a new game with a new word in the current genre."""
    genre = session.get('current_genre', GENRE_LIST[0])
    initialize_game_session(genre)
    return redirect(url_for('hangman_game'))


if __name__ == '__main__':
    # When running locally, ensure DB setup happens
    with app.app_context():
        db.create_all()
    app.run(debug=True)